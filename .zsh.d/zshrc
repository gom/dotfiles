# key bind
bindkey -e

# prompt
setopt prompt_subst
autoload -Uz colors && colors
setopt prompt_percent
setopt transient_rprompt
PROMPT="${USER}@${HOST} %(!.#.$) "

autoload -Uz vcs_info
zstyle ':vcs_info:*' formats '(%s)-[%b]'
zstyle ':vcs_info:*' actionformats '(%s)-[%b|%a]'
precmd () {
    psvar=()
    LANG=C vcs_info >&/dev/null
    [[ -n "$vcs_info_msg_0_" ]] && psvar[1]="$vcs_info_msg_0_"
}
RPROMPT="%1(v|%F{green}%1v%f|)"
RPROMPT+="[%~]"

setopt no_flow_control      # disabled C-s, C-q
setopt no_beep
setopt interactive_comments # behind '#' is comment in cmd line
WORDCHARS=${WORDCHARS:s,/,,}

# log
watch="all"    # watching login and logout
log
setopt no_tify # when bg job finish, notify me.
setopt nomatch
setopt ignore_eof # ignore logout when touch ^D

# job
setopt long_list_jobs
REPORTTIME=3

## auto complete
zstyle :compinstall filename '~/.zshrc'
fpath=(~/.zsh.d/completion $fpath)
autoload -Uz compinit && compinit -u
autoload -Uz bashcompinit && bashcompinit

zstyle ':completion:*' format '%B%d%b'
zstyle ':completion:*' group-name ''
zstyle ':completion:*:default' menu select=2        #use emacs keybind
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z} r:|[._-]=*' # ignore case
zstyle ':completion:*' completer \
      _oldlist _complete _match _history _ignored _approximate _prefix
zstyle ':completion:*' use-cache yes
zstyle ':completion:*' verbose yes
zstyle ':completion:sudo:*' environ PATH="$SUDO_PATH:$PATH"
zstyle ':completion:*:default' list-colors ${LSCOLORS}
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([%0-9]#)*=0=01;31'

# cdr http://blog.n-z.jp/blog/2013-11-12-zsh-cdr.html
if [[ -n $(echo ${^fpath}/chpwd_recent_dirs(N)) && -n $(echo ${^fpath}/cdr(N)) ]]; then
  autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs
  zstyle ':completion:*:*:cdr:*:*' menu selection
  zstyle ':completion:*' recent-dirs-insert both
  zstyle ':chpwd:*' recent-dirs-max 500
  zstyle ':chpwd:*' recent-dirs-default true
  zstyle ':chpwd:*' recent-dirs-file "${XDG_CACHE_HOME:-$HOME/.cache}/shell/chpwd-recent-dirs"
  zstyle ':chpwd:*' recent-dirs-pushd true
fi

setopt complete_in_word
setopt glob_complete
setopt extended_glob
setopt numeric_glob_sort    # sort as numeric order
setopt mark_dirs            # add / when the path is directory
setopt hist_expand
setopt auto_list            # display autocomplete list by ^I
setopt list_types        # display file types in complete list
setopt auto_menu         # switch items by TAB
setopt magic_equal_subst # able to complete after '='
setopt print_eight_bit   # display Japanese


# moving directory
setopt auto_cd
setopt auto_pushd        # cd to pushd
setopt pushd_ignore_dups
setopt pushd_to_home     # pushd with no argument, go home.
cdpath=(~)
chpwd_functions=($chpwd_functions dirs) # display the stack of directories


## history
HISTFILE=~/.zsh_history
HISTSIZE=10000000
SAVEHIST=$HISTSIZE
function history-all { history -E 1 } # output all histories

autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end

setopt extended_history     # write datetime to history
setopt append_history       # add .zsh_history
setopt inc_append_history   # add history with incremental
setopt hist_ignore_all_dups # when dups command on history, delete old one
setopt hist_ignore_dups     # ignore same cmd
setopt hist_ignore_space    # when cmd starting space, ignore history
setopt share_history
setopt hist_no_store        # no store in history, `history` cmd.
setopt hist_reduce_blanks
setopt hist_verify

## set alias
setopt complete_aliases

case ${OSTYPE} in
  linux*)
    alias ls='ls --color=auto'
    ;;
esac

alias ll='ls -lhF'
alias la='ls -la'
alias grep='grep --color=auto'
alias ec='emacsclient -c -t'
alias em='emacs -nw -fs'

alias rr="command rm -rf"
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -i'

alias pd='pushd'
alias po='popd'
alias gd='dirs -v; echo -n "select number: "; read newdir; cd +"$newdir"'
alias lss='less -MN'

alias sc='screen'
alias sd='screen -D'
alias t='tmux'
alias ta='tmux attach'
alias td='tmux detach'
alias g='git'

alias re='ruby -e'
alias spec='spec -c -fs'

alias -g L='| less'
alias -g H='| head'
alias -g T='| tail'
alias -g G='| grep'
alias -g W='| wc'
alias -g S='| sed'
alias -g A='| awk'

alias utf='export LANG=ja_JP.UTF-8; export LANGUAGE=ja_JP.UTF-8; export LC_ALL=ja_JP.UTF-8'
alias en='export LANG=en; export LANGUAGE=en; export LC_ALL=en'
alias eucjp='export LANG=ja_JP.eucJP; export LANGUAGE=ja_JP.eucJP; export LC_ALL=ja_JP.eucJP'
alias sjis='export LANG=ja_JP.SJIS; export LANGUAGE=ja_JP.SJIS; export LC_ALL=ja_JP.SJIS'

grm() {
  git status | grep deleted: | awk '{ print $2 }' | xargs git rm
}

## others
umask 022

## auto attach screen / tmux
if which screen 2>&1 > /dev/null; then
  screen -q -ls
  num=$?
  if [ $num -eq 9 ]; then
    # screen -xR
  elif [ $num -eq 11 ]; then ## 9: no session, 10: session cannot atattch, 11: session can attach
    screen -xr
  elif [ $num -eq 10 ]; then
    screen -ls
  fi
fi

if which tmux 2>&1 > /dev/null; then
  [ -z $TMUX ] && (tmux -u attach || tmux -u)
fi

show_virtual_env() {
  if [ -n "$VIRTUAL_ENV" ]; then
    echo "(venv:${VIRTUAL_ENV##*/})"
  fi
}

PS1='$(show_virtual_env)'$PS1

## direnv, rbenv, pyenv
[ -s "`which direnv`" ] && eval "$(direnv hook zsh)"
[ -s "`which rbenv`" ] && eval "$(rbenv init -)"
[ -s "`which pyenv`" ] && eval "$(pyenv init -)"

## goenv
[ -s "`which goenvwrapper.sh`" ] && source goenvwrapper.sh > /dev/null

#pythonz
[[ -s $HOME/.pythonz/etc/bashrc ]] && source $HOME/.pythonz/etc/bashrc

## ssh-agent
[ -e $HOME/.ssh/agent-env ] && source $HOME/.ssh/agent-env

## for Emacs Shell
[[ $EMACS = t ]] && unsetopt zle
## for tramp
case "$TERM" in
  dumb | emacs)
    PROMPT="%m:%~> "
    unsetopt zle
    ;;
esac

# peco
if [ -s "`which peco`" ]; then
  function peco-select-history() {
    local tac
    if which tac > /dev/null; then
      tac="tac"
    else
      tac="tail -r"
    fi
    BUFFER=$(history -n 1 | \
      eval $tac | \
      peco --query "$LBUFFER")
    CURSOR=$#BUFFER
    zle clear-screen
  }
  zle -N peco-select-history
  bindkey '^r' peco-select-history

  if [ -s "`which ghq`" ]; then
    function peco-src () {
      local selected_dir=$(ghq list --full-path | peco --query "$LBUFFER")
      if [ -n "$selected_dir" ]; then
        BUFFER="cd ${selected_dir}"
        zle accept-line
      fi
      zle clear-screen
    }
    zle -N peco-src
    bindkey '^]' peco-src
  fi

  function peco-cdr () {
    local selected_dir=$(cdr -l | awk '{ print $2 }' | peco)
    if [ -n "$selected_dir" ]; then
      BUFFER="cd ${selected_dir}"
      zle accept-line
    fi
    zle clear-screen
  }
  zle -N peco-cdr
  bindkey '^[' peco-cdr
fi
